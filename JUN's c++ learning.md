

# **JUN's C++ learning**

## 1. C++简介

### 1. 面向对象编程(OOP)

在C语言的**过程性编程**中，程序是由**函数**和**过程**组成的，数据通过参数传递，逻辑通过函数调用来组织。其核心思想是将程序分解为小的、可重复使用的函数，从而提高代码的可读性、可维护性和复用性。

而C++继承了C语言的高效性和底层操作能力，并在此基础上增添了很多功能

C++引入了面向对象编程的四大基本概念：

- **类和对象**：类是数据和操作数据的函数的封装，对象是类的实例
- **继承**：子类可以继承父类的属性和方法，重用代码并增强可扩展性
- **多态**：通过函数重载和虚函数实现多态性，使得同一个函数可以有不同的行为
- **封装**：通过访问修饰符（如`private`, `protected`, `public`）控制类成员的访问权限
- **抽象**：隐藏实现细节，提供统一的接口

### 2. 泛型编程

C++支持模板（template），使得函数和类可以编写成与数据类型无关的形式，增强了代码的复用性。模板用于实现**泛型编程**，如STL（标准模板库）中的容器、迭代器等都是基于模板实现的

## 2. 基础内容

### 1. 注释

1. 单行注释：

   ```
   // 描述信息
   ```

   - 通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明

2. 多行注释：

   ```
   /* 描述信息 */
   ```

   - 通常放在一段代码的上方，对该段代码做整体说明
   
### 2. 关键字

 1. **`#define`** 宏常量： `#define 常量名 常量值`
 2. **`const`**修饰的变量 `const 数据类型 常量名 = 常量值`

### 3. iostream文件

1. `cout`打印输出

   - `using`编译指令

     通过`using namespace std;`，你告诉编译器使用`std`命名空间，这样你就不需要在每次使用标准库中的内容时都加上`std::`前缀，但在大型项目中全局使用可能会带来命名冲突问题，或使代码的可读性降低

   - `std`命名空间

     `std` 是 C++ 标准库的命名空间。所有标准库中的内容都包含在这个命名空间中，如 `cout`, `cin`, `endl`, `vector`, `string` 等

   - 解决中文输出乱码问题（转化为UTF8）

     1. 引入`windows.h`，并在main函数内调用`SetConsoleOutputCP(CP_UTF8);`
     2. `main`函数内部编写`system("chcp 65001")`

   ```c++
   #include<iostream>
   #include "windows.h"
   
   int main() 
   {
   	int a = 10;
       //设置控制台输出产生的字符编码
       SetConsoleOutputCP(CP_UTF8);
       //可理解为向cout流入数据并输出
   	std::cout << "值a = " << a << std::endl;
       
   	system("pause");//使程序停止运行
   
   	return 0;
   }
   ```

2. `cin`键盘输入

   ```c++
   #include<iostream>
   #include "windows.h"
   
   int main() 
   {
   	int a;
       //设置控制台输出产生的字符编码
       SetConsoleOutputCP(CP_UTF8);
       //可理解为向a流入数据
       std::cin >> a;
   	std::cout << "输入的值" 
           	  << "a = "
          		  << a 
           	  << std::endl;
       
   	system("pause");//使程序停止运行
   
   	return 0;
   }
   ```

### 4. 数据类型

- 整形

  | **数据类型**        | **占用空间**                                    | 取值范围         |
  | ------------------- | ----------------------------------------------- | ---------------- |
  | short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
  | int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
  | long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
  | long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |

- 浮点型

  | **数据类型** | **占用空间** | **有效数字范围** |
  | ------------ | ------------ | ---------------- |
  | float        | 4字节        | 7位有效数字      |
  | double       | 8字节        | 15～16位有效数字 |

- 字符型

  | **数据类型** | **占用空间** | **用法**                     |
  | ------------ | ------------ | ---------------------------- |
  | char         | 1字节        | `char ch = 'a';`             |
  | string       |              | `string 变量名 = "字符串值"` |

### 5. 程序流程结构

1. **三目运算符**

   **作用：** 通过三目运算符实现简单的判断

   **语法：**`表达式1 ? 表达式2 ：表达式3`

   **解释：**

   如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

   如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

   ```c++
   int main() {
     int a =10 ,b = 20 ,c = 0;
     c = a > b ? a : b;
     cout << "c = " << c << endl;
   
     //C++中三目运算符返回的是变量,可以继续赋值
   
     (a > b ? a : b) = 100;
   
     cout << "a = " << a << endl;
     cout << "b = " << b << endl;
     cout << "c = " << c << endl;
   
     return 0;
   }
   ```
   
2. **switch语句**

   作用：执行多条件分支语句

   **语法：**

   ```c++
   switch(表达式) {
   
   	case 结果1：执行语句;break;
   
   	case 结果2：执行语句;break;
   
   	...
   
   	default:执行语句;break;
   
   }
   ```
   
3. **跳转语句**

   - break语句

     **作用:** 用于跳出选择结构或者循环结构

   - continue语句

     **作用：**在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

   - goto语句

     **作用：**可以无条件跳转语句

     **语法：** `goto 标记;`

### 6. 数组

**二维数组定义方式**

1. `数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
2. `数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};`

**二维数组数组名**

- 二维数组名就是这个数组的首地址
- 对二维数组名进行`sizeof`时，可以获取整个二维数组占用的内存空间大小

### 7. 函数

**函数的分文件编写**

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为`.h`的头文件
2. 创建后缀名为`.cpp`的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

## 3. 关键内容

### 1. 指针

#### 1.1 指针的基本概念

**指针的作用：** 可以通过指针间接访问内存

- 指针也是一个数据类型，在32位操作系统下指针占4个字节空间大小，不管什么数据类型
- 指针就是一个地址
- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以利用指针变量保存地址

#### 1.2 指针变量的定义和使用

指针变量定义语法： `数据类型 * 变量名；`

**示例：**

```c++
int main() {
	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;

	//指针变量赋值
	p = &a; //指针指向变量a的地址
	cout << &a << endl; //打印数据a的地址
	cout << p << endl;  //打印指针变量p

	//2、指针的使用,指针前面加*就是解引用，通过解引用的方法找到指针指向的内存中的数据
	cout << "*p = " << *p << endl;

	return 0;
}
```

指针变量和普通变量的区别

- 普通变量存放的是数据,指针变量存放的是地址
- 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用

> 总结1： 我们可以通过 & 符号 获取变量的地址

> 总结2：利用指针可以记录地址

> 总结3：对指针变量解引用，可以操作指针指向的内存

#### 1.3 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的

- 0~255之间的内存编号是系统占用的，因此不可以访问

**野指针**：指针变量指向非法的内存空间

**注意：**

- 空指针和野指针都不是我们申请的空间，因此不要访问。
- 并且存储数据需要先为数据提供空间再存储，如先定义指针指向的空间再进行数据存入
- `(int *)`可把数据强转为地址，如`pt = (int *) 0xb8000000`

#### 1.4 数组指针

**作用：**利用指针访问数组中元素

```c++
int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

	int * p = arr;  //指向数组首地址的指针

	cout << "第一个元素： " << arr[0] << endl;
	cout << "指针访问第一个元素： " << *p << endl;

	for (int i = 0; i < 10; i++) {
		//利用指针遍历数组
		cout << *p << endl;
		p++;
	}

	return 0;
}
```

#### 1.5 函数指针

**作用：**相比值传递，利用指针作函数参数，可以修改实参的值

```c++
//值传递
void swap1(int a ,int b) {
	int temp = a;
	a = b; 
	b = temp;
    //局部变量不影响外部实参
}
//地址传递
void swap2(int * p1, int *p2) {
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {
    int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参
	swap2(&a, &b); //地址传递会改变实参

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	return 0;
}
```

> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递

#### 1.6 `const`修饰指针

`const`修饰指针有三种情况

1. `const`修饰指针 — 常量指针
2. `const`修饰常量 — 指针常量
3. `const`即修饰指针，又修饰常量

```c++
int main() {
	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	
	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误

	return 0;
}
```

### 2. 结构体

#### 2.1 结构体基本概念

结构体属于用户自定义的数据类型，允许用户存储不同的数据类型

#### 2.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

```c++
struct student {
  //成员列表
  string name;  //姓名
  int age;      //年龄
  int score;    //分数
};

//结构体变量创建方式1
student stu;
//结构体变量创建方式2
student stu1 = { "李四",19,60 };
```

#### 2.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**` struct 结构体名 数组名[元素个数] = { {} , {} , ... {} }`

```c++
//结构体定义
struct student {
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}

int main() {
	//结构体数组初始化
	struct student arr[3]=
	{
		{"张三",18,80 },
		{"李四",19,60 },
		{"王五",20,70 }
	};

	return 0;
}
```

#### 2.4 结构体指针

**作用：**通过指针访问结构体中的成员

**使用结构体指针**

1. **节省内存和提高效率**：
   - 当结构体非常大时，传递结构体的副本（即按值传递）会占用大量内存并降低性能。使用结构体指针可以避免复制整个结构体，只需要传递结构体的地址，占用较少的内存
2. **动态分配内存**：
   - 结构体指针可以与动态内存分配函数（如 `malloc`）结合使用，动态创建结构体对象。这在你不知道结构体数量或大小的情况下非常有用
3. **指向结构体数组**：
   - 使用指针可以轻松操作结构体数组，特别是当你需要在函数间传递数组时，指针是必不可少的
4. **修改结构体内容**：
   - 如果你在函数中传递结构体指针，函数可以直接修改结构体中的数据，而不需要返回整个结构体（因为按值传递的话是返回副本）

**用法：**

- `struct student * p = &stu`   指针指向结构体变量
- 利用操作符 `-> `可以通过结构体指针访问结构体属性

```c++
//结构体定义
struct student {
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};


int main() {
	struct student stu = { "张三",18,100, };
	struct student * p = &stu;
	
	p->score = 80; //指针通过 -> 操作符可以访问成员

	cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;

	return 0;
}
```

#### 2.5 结构体做函数参数

**作用：**将结构体作为参数向函数中传递

传递方式有两种：

- 值传递
- 地址传递

```c++
//学生结构体定义
struct student {
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(student stu ) {
	stu.age = 28;
	cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
}

//地址传递
void printStudent2(student *stu) {
	stu->age = 28;
	cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;
}

int main() {
	student stu = { "张三",18,100};
	//值传递
	printStudent(stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;

	cout << endl;

	//地址传递
	printStudent2(&stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;

	return 0;
}
```

> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递

#### 2.6 结构体中`const`使用场景

**作用：**用`const`来防止误操作

```c++
//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu->age = 100; //操作失败，因为加了const修饰
	cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;

}
```

### 3. 内存分区模型

#### 3.1 内存分区

C++程序在执行时，将内存大方向划分为**4个区域**

- **代码区：**存放函数体的二进制代码，由操作系统进行管理的

- **全局区：**存放全局变量和静态变量以及常量,还包含常量区（`const`修饰的）

- **栈区：**

  由编译器自动分配释放, 存放函数的参数值,局部变量等

  如局部变量存放在栈区，执行完该函数将自动释放（编译器会保留一次局部变量，第二次将不再保留），不能返回局部变量的值，为非法行为

- **堆区：**

  由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存，堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete

#### 3.2 new操作符

C++中利用new操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete

**语法：**` new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针

`int* ptr = new int(10);`
`new int(10)` 分配了一个 `int` 类型的内存空间，并初始化为 10。
`ptr` 保存了分配的内存空间的首地址，也就是指向这个 `int` 类型的内存区域

**示例1： 基本语法**

```c++
int* func() {
	int* a = new int(10);
	return a;
}

int main() {
    //在堆区开辟内存
	int *p = func();

	cout << *p << endl;
	cout << *p << endl;

	//利用delete释放堆区数据
	delete p;

	//cout << *p << endl; //报错，释放的空间不可访问

	return 0;
}
```

**示例2： 开辟数组**

```c++
//堆区开辟数组
int main() {
    //创建10个元素数组的空间，在堆区，arr存放该数组内存的首地址
	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	return 0;
}
```

### 4. 引用

#### 4.1 引用的基本概念

本质：**引用的本质在c++内部实现是一个指针常量.**

在 C++ 中，**引用（Reference）** 是一种为变量创建别名的机制，允许程序员通过多个名字访问同一个内存位置。引用的基本概念和指针类似，但使用起来更为简洁，并且引用一旦初始化就不能再指向其他内存，但指针可以。

#### 4.2 引用的定义和使用

**作用： **引用是某个已存在变量的别名，定义时使用 `&` 符号

**语法：** `数据类型 &别名 = 原名`

```c++
int a = 10;
int &ref = a;  // ref 是 a 的引用
```

在这段代码中，`ref` 是变量 `a` 的引用，它和 `a` 指向的是同一块内存。对 `ref` 的任何操作都相当于对 `a` 进行操作

**注意事项：**

- **必须初始化**：引用在定义时必须绑定到一个变量，不能留空
- **不可更改绑定**：一旦引用初始化，它就无法再指向其他变量
- **没有 NULL 引用**：引用总是必须指向一个合法的变量或对象，不能指向空值。不同于指针，引用不能是 `nullptr`

#### 4.3 引用做函数参数

**作用：**函数传参时，可以利用引用的技术让形参修饰实参，避免复制大对象，提高效率

**优点：**可以简化指针修改实参

**按值传递：**函数会复制传递进来的变量值，函数内部对参数的修改不会影响原始变量

**引用传递：**通过传递引用，函数能够直接操作传入的变量，不会进行拷贝，节省内存并提高效率任何在函数内部对引用的修改，都会直接反映在调用者的变量上(可以理解为指针中对地址指向的内容进行修改，而不是值传递中的先拷贝值再存储)

```c++
//1. 值传递
void mySwap01(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}

//2. 地址传递
void mySwap02(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

//3. 引用传递
void mySwap03(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {
	int a = 10;
	int b = 20;

	mySwap01(a, b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap02(&a, &b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap03(a, b);
	cout << "a:" << a << " b:" << b << endl;

	return 0;
}
```

> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

#### 4.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的，可以通过返回引用使函数返回的值可直接修改

用法：函数调用作为左值

**注意：**

- 当函数返回引用时，函数返回的是对象的地址或内存中的位置，而不是该对象的副本
- 调用者可以直接对返回的对象进行操作，修改它的内容
- 返回引用可以避免对象的拷贝开销，提升性能
- 需要注意的是**不要返回局部变量**引用，返回局部变量的引用会导致未定义行为，因为返回的引用指向的内存已经无效
- 还可以通过**static(全局区)**延续局部变量的生命周期，从而实现函数内变量的返回

```c++
//可以理解为int& getElement(int arr[], int index) = arr[index]，getElement()为arr[index]别名
int& getElement(int arr[], int index) {
    return arr[index];  // 返回数组元素的引用
}
int main() {
	int myArray[5] = {1, 2, 3, 4, 5};
    
    getElement(myArray, 2) = 10;  // 直接修改数组中的第三个元素
 
	cout << "myArray[2]:" << myArray[2] << endl;
	return 0;
}
```

#### 4.5 常量引用

**作用：**常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加const修饰形参，防止形参改变实参

```c++
//引用使用的场景，通常用来修饰形参,const：只读类型
void showValue(const int& v) {
	//v += 10;
	cout << v << endl;
}

int main() {
	//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
	//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;
	const int& ref = 10;

	//ref = 100;  //加入const后不可以修改变量
	cout << ref << endl;

	//函数中利用常量引用防止误操作修改实参
	int a = 10;
	showValue(a);
    
	return 0;
}
```

#### **4.6 将引用用于结构**

在 C++ 中，引用不仅可以用于基本数据类型，也可以用于自定义的复杂数据类型，例如结构体（`struct`）

通过引用传递结构体对象，可以避免拷贝整个结构体。以下是通过引用传递 `Point` 结构体的示例：

```c++
#include <iostream>

struct Point {
    int x;
    int y;
};

// 使用引用作为参数
void movePoint(Point &p, int dx, int dy) {
    p.x += dx;
    p.y += dy;
}

int main() {
    Point p1 = {10, 20};
    
    // 使用引用传递，避免拷贝
    movePoint(p1, 5, -3);
    
    std::cout << "p1.x: " << p1.x << ", p1.y: " << p1.y << std::endl;  // 输出: p1.x: 15, p1.y: 17
    
    return 0;
}

```

#### 4.7 将引用用于类对象



### 5. 类和对象

#### 5.1 类和对象的基本概念

在C++中，**类和对象**是面向对象编程（OOP）的核心概念。通过类和对象，C++提供了一种模块化的、抽象的编程方式

1. **类 (Class)**

   **类**是一个用户定义的数据类型，它封装了数据和操作数据的函数（称为方法或成员函数）。类是对现实世界实体的抽象，定义了对象的属性和行为。

   **类的基本结构：**
   
   ```c++
   class ClassName {
   public:
       // 构造函数
       ClassName();
   
       // 成员变量 (属性)
       int attribute1;
       double attribute2;
   
       // 成员函数 (行为)
       void method1();
       int method2(int param);
   };
   ```
   
   - **成员变量：**类中的数据（属性），定义了对象的状态。
   
   - **成员函数：**类中的函数（行为），定义了对象可以执行的操作。

2. **对象 (Object)**

   **对象**是类的实例化。类是一个模板，而对象是根据类创建的具体实例。通过对象，能够访问类的成员变量和成员函数。

   在C++中，可以通过类来**创建对象**，使用**构造函数**来初始化对象的属性。

**创建对象：**

```c++
int main() {
    // 使用类创建对象
    Person person1("Alice", 25);
    Person person2("Bob", 30);

    // 调用对象的成员函数
    person1.introduce();
    person2.introduce();

    return 0;
}
```

3. **类和对象的关系**

   - **类是模板**：类定义了对象的属性和行为，但不具体占用内存，直到创建对象时才分配内存。
   - **对象是类的实例**：对象是具体的，通过类定义的结构，可以对对象进行操作和使用。


> C++面向对象的三大特性为：封装、继承、多态

#### 5.2 封装

1. **封装的意义**

   **封装**（Encapsulation）是面向对象编程的一个核心原则

   - 将数据（成员变量）和操作数据的函数（成员函数）捆绑在一起

   - 通过访问控制来隐藏类的内部实现细节，只允许外部通过特定的接口访问这些数据。

   | **访问权限**        | 类内         | 类外                                             |
   | ------------------- | ------------ | ------------------------------------------------ |
   | public(公共权限)    | 类内可以访问 | 类外可以访问                                     |
   | protected(保护权限) | 类内可以访问 | 类外不可以访问(但子类可以访问父类中的保护内容)   |
   | private(私有权限)   | 类内可以访问 | 类外不可以访问(但子类不可以访问父类中的私有内容) |

   **示例：**

   ```c++
   class BankAccount {
   private:
       double balance;  // 余额是私有的，不能直接访问
   
   public:
       void deposit(double amount) 
       {
           if (amount > 0) balance += amount;  // 确保存款为正数
       }
   
       void withdraw(double amount) 
       {
           if (amount > 0 && amount <= balance) balance -= amount;  // 确保取款合法
       }
   
       double getBalance() const 
       {
           return balance;
       }
   };
   ```

   在这个例子中，`balance`是私有的，外部代码不能直接访问或修改。只能通过`deposit()`和`withdraw()`方法来操作账户余额，这样确保了余额的合理性和安全性。

   > **类比**：把封装看作是一个“黑箱”操作，外部只需要使用类提供的功能，而无需了解其内部的实现过程

2. **struct和class区别**

   在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

   **区别：**

   - struct 默认权限为公共
   - class 默认权限为私有

#### 5.3 对象的初始化和清理

C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

对象的**初始化和清理**也是两个非常重要的安全问题

 一个对象或者变量没有初始状态，对其使用后果是未知

 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**，**编译器提供的构造函数和析构函数是空实现**

##### **5.3.1 构造函数和析构函数**

1. **对象的初始化：构造函数 (Constructor)**

   构造函数是一个特殊的成员函数，用于在对象创建时进行初始化。它的名字与类名相同，且没有返回类型（即使是`void`也不写）。构造函数可以有参数，也可以没有参数（称为**默认构造函数**）

   - **构造函数语法：**`类名(){}`

   - **构造函数的特点：**
     - 名字与类名相同
     - 没有返回类型
     - 在对象创建时自动调用，不需要显式调用
     - 可以被重载，即可以定义多个构造函数（不同的参数）

   - **构造函数使用示例：**

   ```c++
   #include <iostream>
   using namespace std;
   
   class Person {
   private:
       string name;
       int age;
   
   public:
       // 默认构造函数
       Person() {
           name = "Unknown";
           age = 0;
           cout << "Default constructor called!" << endl;
       }
   
       // 带参数的构造函数
       Person(string n, int a) {
           name = n;
           age = a;
           cout << "Parameterized constructor called!" << endl;
       }
       
       //拷贝构造函数
   	Person(const Person& p) {
           name = p.name;
   		age = p.age;
   		cout << "copy constructor called!" << endl;
   	}
   
       // 成员函数
       void introduce() {
           cout << "Hi, I'm " << name << " and I'm " << age << " years old." << endl;
       }
   };
   
   int main() {
       // 使用默认构造函数
       Person person1;
       person1.introduce();
   
       // 使用带参数的构造函数
       Person person2("Alice", 30);
       person2.introduce();
       
       // 使用拷贝构造函数
       Person person3(person2);
   	person3.introduce();
       
       return 0;
   }
   
   ```

   - **三种构造函数：**

     1. **默认构造函数**：不接受任何参数，初始化`name`为`"Unknown"`，`age`为`0`。

     2. **带参数的构造函数**：接受两个参数`n`和`a`，用于初始化`name`和`age`。

     3. **拷贝构造函数**：拷贝一个已经创建完毕的对象`person2`来初始化一个新对象`person3`的`name`和`age`

        拷贝构造函数调用时机通常有三种情况：

        - 使用一个已经创建完毕的对象来初始化一个新对象
        - 值传递的方式给函数参数传值
        - 以值方式返回局部对象

   - **构造函数调用规则：**

     默认情况下，c++编译器至少给一个类添加3个函数

     1．默认构造函数(无参，函数体为空)

     2．默认析构函数(无参，函数体为空)

     3．默认拷贝构造函数，对属性进行值拷贝

     构造函数调用规则如下：

     - 如果用户**定义有参构造函数**，c++不在提供默认无参构造（故需要用户自定义默认无参构造），但是会提供默认拷贝构造
     - 如果用户**定义拷贝构造函数**，c++不会再提供其他构造函数

   - **构造函数的作用：**
     - **对象的初始化：**构造函数通常用于为类的成员变量赋初值。如：如果类包含指针或其他资源，构造函数可以为其分配内存或进行初步设置。
     - **提供默认行为：**如果没有显式定义构造函数，C++编译器会提供一个默认构造函数，用于不接受任何参数的对象初始化。
     - **构造函数重载：**构造函数可以被重载，意味着可以为不同的构造方式提供多个构造函数。如：可以为带参数和不带参数的对象创建不同的构造函数。
     - **复杂对象的初始化：**构造函数可以用于复杂的初始化过程，比如为对象的成员分配动态内存，或通过传递参数来初始化某些特定属性。
     - **初始化列表：**构造函数可以使用初始化列表(initializer list)来对常量成员（const）、引用成员（&）或需要提前初始化的成员进行初始化。

2. **对象的清理：析构函数 (Destructor)**

   析构函数是一个特殊的成员函数，它用于在对象的生命周期结束时释放资源或执行清理操作。析构函数的名字是在类名前加上波浪号（`~`），且没有返回类型和参数。它在对象被销毁时**自动调用**。

   - **析构函数语法：**`~类名(){}`
   - **析构函数特点：**
     - 名字与类名相同，前面有一个波浪号（`~`）
     - 没有返回类型，也不能有参数
     - 当对象生命周期结束时（如对象超出作用域或显式删除时）自动调用
     - 主要用于释放资源，例如内存、文件句柄或网络连接等

   - **析构函数使用示例：**

     ```c++
     #include <iostream>
     using namespace std;
     
     class Person {
     private:
         string name;
         int age;
     
     public:
         // 构造函数
         Person(string n, int a) {
             name = n;
             age = a;
             cout << "Constructor called for " << name << endl;
         }
     
         // 析构函数
         ~Person() {
             cout << "Destructor called for " << name << endl;
         }
     
         // 成员函数
         void introduce() {
             cout << "Hi, I'm " << name << " and I'm " << age << " years old." << endl;
         }
     };
     
     void Local_Object() {
         // 创建局部对象
         Person person1("person1", 30);
         person1.introduce();
     } // person1超出作用域时，析构函数会被自动调用
     
     int main() {
         Local_Object();
         Person person2("person2", 40);
         person2.introduce();
     
         return 0; // 程序结束时，person2的析构函数会被调用
     }
     
     ```

     > **在该例中：**
     >
     > **构造函数**：用于初始化对象，创建`person1`和`person2`时分别调用了构造函数。
     >
     > **析构函数**：用于清理对象，`person1`在其生命周期结束时调用析构函数，`person2`在`main`函数结束时调用析构函数。











































































